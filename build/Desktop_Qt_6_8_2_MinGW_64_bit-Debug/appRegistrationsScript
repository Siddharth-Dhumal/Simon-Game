<#
.SYNOPSIS
    Azure AD App Registrations Auditor with bulletproof error handling and logging.

.DESCRIPTION
    Connects to Microsoft Graph, retrieves applications, owners, permissions, and credential expirations.
    Exports a CSV report and email it, logging every step with severity levels so that no error escapes unnoticed.

.PARAMETER OutputFile
    Path to the CSV output file.

.PARAMETER LogFile
    Path to the log file.

.PARAMETER EmailTo
    Recipient email address for the report.

.PARAMETER EmailFrom
    Sender email address for the report.

.PARAMETER SmtpServer
    SMTP server for sending the email.
#>
Param(
    [string]$OutputFile   = "AppRegistrations.csv",
    [string]$LogFile      = "AppRegistrations.log",
    [string]$EmailTo      = 'u1427950@umail.utah.edu',
    [string]$EmailFrom    = 'AzureAuditBot <adcron@utah.edu>',
    [string]$SmtpServer   = 'smtp.utah.edu'
)

# Ensure any error stops execution
$ErrorActionPreference = 'Stop'

# Centralized logging function
function Write-Log {
    param(
        [Parameter(Mandatory)]
        [ValidateSet('INFO','WARN','ERROR')]
        [string]$Level,
        [Parameter(Mandatory)]
        [string]$Message
    )
    $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
    $entry     = "$timestamp [$Level] - $Message"
    Add-Content -Path $LogFile -Value $entry
    if ($Level -eq 'ERROR') {
        Write-Host $entry -ForegroundColor Red
    } elseif ($Level -eq 'WARN') {
        Write-Host $entry -ForegroundColor Yellow
    } else {
        Write-Host $entry
    }
}

# Archive old log, start fresh
if (Test-Path $LogFile) {
    Rename-Item $LogFile -NewName ("{0}.{1}.bak" -f $LogFile, (Get-Date -Format "yyyyMMddHHmmss")) -ErrorAction SilentlyContinue
}
New-Item $LogFile -ItemType File -Force | Out-Null
Write-Log -Level INFO -Message "=== Script execution started ==="

# Global trap for any uncaught exception
trap {
    Write-Log -Level ERROR -Message "Unhandled exception: $($_.Exception.Message)`n$($_.ScriptStackTrace)"
    exit 1
}

function Assert-Module {
    param([string]$Name)
    if (-not (Get-Module -ListAvailable -Name $Name)) {
        Write-Log -Level ERROR -Message "Required module '$Name' is not installed or accessible."
        exit 1
    }
    Write-Log -Level INFO -Message "Module '$Name' is present."
}

function Connect-Graph {
    try {
        Write-Log -Level INFO -Message "Connecting to Microsoft Graph..."
        Connect-MgGraph -Scopes "Application.Read.All","Directory.Read.All" -ErrorAction Stop
        Write-Log -Level INFO -Message "Connected to Microsoft Graph."
    } catch {
        Write-Log -Level ERROR -Message "Failed to connect to Microsoft Graph: $($_.Exception.Message)"
        exit 1
    }
}

function Get-ServicePrincipal {
    param([string]$AppId)
    try {
        Write-Log -Level INFO -Message "Retrieving service principal for AppId '$AppId'..."
        $sp = Get-MgServicePrincipal -Filter "appId eq '$AppId'" -ErrorAction Stop
        if (-not $sp) {
            throw "No service principal found for AppId $AppId"
        }
        Write-Log -Level INFO -Message "Service principal retrieved."
        return $sp
    } catch {
        Write-Log -Level ERROR -Message "Could not retrieve service principal: $($_.Exception.Message)"
        exit 1
    }
}

function Build-PermissionTables {
    param($ServicePrincipal)
    Write-Log -Level INFO -Message "Building permission lookup tables..."
    $delegated = @{ }
    foreach ($scope in $ServicePrincipal.Oauth2PermissionScopes) {
        $delegated[$scope.Id] = $scope.Value
    }
    $appRoles = @{ }
    foreach ($role in $ServicePrincipal.AppRoles) {
        $appRoles[$role.Id] = $role.Value
    }
    Write-Log -Level INFO -Message "Permission tables ready."
    return @{ Delegated = $delegated; App = $appRoles }
}

function Retrieve-Applications {
    try {
        Write-Log -Level INFO -Message "Retrieving all Azure AD applications..."
        $apps = Get-MgApplication -All -ErrorAction Stop
        if (-not $apps) {
            throw "No applications returned from Graph."
        }
        Write-Log -Level INFO -Message "$($apps.Count) applications retrieved."
        return $apps
    } catch {
        Write-Log -Level ERROR -Message "Failed to get applications: $($_.Exception.Message)"
        exit 1
    }
}

function Process-Applications {
    param(
        [array]$Apps,
        [hashtable]$PermTables,
        [string]$GraphServiceAppId
    )
    Write-Log -Level INFO -Message "Processing each application record..."
    $results = [System.Collections.Generic.List[PSObject]]::new()
    foreach ($app in $Apps) {
        try {
            # Basic info
            $displayName = $app.DisplayName
            $appId       = $app.AppId

            # Owners
            $owners = Get-MgApplicationOwner -ApplicationId $app.Id -All -ErrorAction Stop |
                      ForEach-Object {
                          if ($_.AdditionalProperties.displayName) { $_.AdditionalProperties.displayName }
                          elseif ($_.AdditionalProperties.appDisplayName) { $_.AdditionalProperties.appDisplayName }
                          else { $_.Id }
                      }
            if (-not $owners) { $owners = 'No owners' }

            # Permissions
            $perms = @()
            if ($app.RequiredResourceAccess) {
                foreach ($res in $app.RequiredResourceAccess | Where ResourceAppId -eq $PermTables.ServicePrincipal.AppId) {
                    foreach ($perm in $res.ResourceAccess) {
                        $lookup = if ($perm.Type -eq 'Scope') { $PermTables.Delegated[$perm.Id] }
                                  else { $PermTables.App[$perm.Id] }
                        $perms += ($lookup ?? "Unknown Permission (Id: $($perm.Id))")
                    }
                }
            }
            if (-not $perms) { $perms = 'No permissions' }

            # Credentials
            $creds = @()
            foreach ($cert in $app.KeyCredentials) {
                if ($cert.EndDateTime) { $creds += "CertExpires: $($cert.EndDateTime.ToUniversalTime().ToString('u'))" }
            }
            foreach ($sec in $app.PasswordCredentials) {
                if ($sec.EndDateTime) { $creds += "SecretExpires: $($sec.EndDateTime.ToUniversalTime().ToString('u'))" }
            }
            if (-not $creds) { $creds = 'None' }

            # Add to results
            $results.Add([PSCustomObject]@{
                AppDisplayName        = $displayName
                AppId                 = $appId
                Owners                = ($owners -join ', ')
                ApiPermissions        = ($perms   -join '; ')
                CertSecretExpirations = ($creds   -join '; ')
            })
        } catch {
            Write-Log -Level WARN -Message "Error processing app '$($app.DisplayName)': $($_.Exception.Message)"
        }
    }
    Write-Log -Level INFO -Message "Finished processing applications."
    return $results
}

function Export-Results {
    param(
        [System.Collections.Generic.List[PSObject]]$Data,
        [string]$Path
    )
    try {
        Write-Log -Level INFO -Message "Exporting results to CSV '$Path'..."
        $Data | Export-Csv -Path $Path -NoTypeInformation -Force -ErrorAction Stop
        Write-Log -Level INFO -Message "CSV export complete."
    } catch {
        Write-Log -Level ERROR -Message "Failed to export CSV: $($_.Exception.Message)"
        exit 1
    }
}

function Send-ReportEmail {
    param(
        [string]$From,
        [string]$To,
        [string]$Subject,
        [string]$Body,
        [string[]]$Attachments,
        [string]$Smtp
    )
    try {
        Write-Log -Level INFO -Message "Sending email to '$To' via '$Smtp'..."
        Send-MailMessage -From $From -To $To -Subject $Subject -Body $Body `
                         -Attachments $Attachments -Priority High `
                         -DeliveryNotificationOption OnSuccess,OnFailure `
                         -SmtpServer $Smtp -ErrorAction Stop
        Write-Log -Level INFO -Message "Email sent successfully."
    } catch {
        Write-Log -Level ERROR -Message "Failed to send email: $($_.Exception.Message)"
    }
}

# --- MAIN EXECUTION FLOW ---
Assert-Module -Name "Microsoft.Graph"

Connect-Graph

$graphServiceAppId = "00000003-0000-0000-c000-000000000000"
$servicePrincipal   = Get-ServicePrincipal -AppId $graphServiceAppId
$permTables         = Build-PermissionTables -ServicePrincipal $servicePrincipal
$appList            = Retrieve-Applications
$results            = Process-Applications -Apps $appList -PermTables $permTables -GraphServiceAppId $graphServiceAppId
Export-Results     -Data $results -Path $OutputFile

# Prepare and send email
$emailSubject = "Azure AD App Audit Report - $(Get-Date -Format 'yyyy-MM-dd HH:mm')"
$emailBody    = @"
Hello,

Please find attached the latest Azure AD Applications audit report.
Let me know if you encounter any issues.

Regards,
Audit Script
"@
Send-ReportEmail -From $EmailFrom -To $EmailTo -Subject $emailSubject `
                 -Body $emailBody -Attachments @($OutputFile,$LogFile) -Smtp $SmtpServer

Write-Log -Level INFO -Message "=== Script execution finished ==="